# DBI
Простой и быстрый интерфейс к базам данных SQL

# Версия
Этот документ описывает версию 1.0

# Пример использования
````lua
local db = require "DBI" ({
  driver = "MySQL", -- имя файла DBD
  connection = {    -- настройки подключения к серверу базы данных
    hostname = "localhost", database = "lunex", username = "user", password = "p@ssw0rd", codepage = "utf8"
  },
  scheme = {  -- описание таблиц, типов данных и реляционных связей базы данных        
    user  = {               
      id = "number", name = "string", password = "string", group = "group:id"
    },
    group = {
      id = "number", name = "string"
    }
  }
})
users = db.user:limit(100):offset(0):orderBy("name"):get({group = {name = "Admin"}})
for _,u in pairs(users) do
  print (u.name .. ':' .. u.password)
end
````
## Драйвер базы данных (DBD)
Файл с таблицей, содержащей функции `query`, `fetch`, `enquote` и `enquoteVal`. 
Реализация этих функций зависит от базы данных и используемых низкоуровневых библиотек.

## Настройки подключения
Таблица с данными, которые нужны драйверу для того, чтобы подключиться к серверу базы данных. 
Структура таблицы зависит от базы данных и соглашений DBD. 
В примере используются соглашения драйвера `MySQL`.

## Схема
Схема отражает структуру базы данных - имена таблиц, имена колонок и их тип, реляционные связи.
Данные в колонках `string` экранируются скобками при помощи метода `enquoteVal` драйвера.
Если в качестве типа указана связка `таблица:колонка`, то это означает связь "много-к-одному".

**TO DO:** иерархические связи, позволяющие хранить деревья.

# Выполнение SQL-запросов
````lua
users = db:query("SELECT * FROM `user`")
````
# Data Mapping
Запрос, даже вложенный, возвращает линейные неструктурированные данные. 
Но с этим можно справиться.
````lua
users = db:query("
  SELECT u.name as name, g.id as group_id, g.name as group_name FROM `user` as u 
  JOIN group as g ON g.id = u.group
")
print (users[1].name, users[1].group.id, users[1].group.name)
````
Если в именах возвращаемых колонок использовать префиксы и разделитель "_", то эти колонки будут структурированы как дочерние объекты.

# CRUD
## add
````lua
db.group:add({name = "Admin"})
db.user:add({name = "root", group = {name = "Admin"}})
````
Метод add конструирует и выполняет SQL-конструкцию INSERT. 
Если схема предусматривает вложенный реляционный объект, в конструкцию INSERT вкладывается соотвествующий SELECT. 
Таким образом, все вложенные объекты должны существовать на момент выполняния операции, автоматически они не создаются.

## get
````lua
users = db.user:limit(100):offset(0):orderBy("name"):get({group = {name = "Admin"}})
print (users[1].group.name) --> "Admin"
````
Метод формирует и выполняет конструкцию SELECT.
Возвращается массив (таблицу и натуральными числовыми ключами) из записей.
Если поле записи ссылается на запись в другой таблице, то оно становится вложенной таблицой.

Дополнительные методы limit, offset, orderBy, orderByDesc и where дополняют запрос соотвествующими конструкциями.
Они могут следовать в любом порядке, но должны находиться **перед** вызовом :get

## put
````lua
db.user:where('name = "root"'):put({password = "r00t"})
````
Конструирует и выполняет SQL-конструкцию UPDATE.
**Без указания `where` изменения будут выполнены для всех записей таблицы.**
## del
````lua
db.user:del({group = {name = "Guest"}}) 
db.group:del({name = "Guest"})
````
Метод конструирует и выполняет конструкцию DELETE FROM. 
**Внимание: если передать методу пустую таблицу, будут удалены все записи.**
